---
title: "Empirical Bayes Estimation"
author: "Alex Cookson"
date: "31/05/2020"
output: html_document
---

Ratings sites -- like Rotten Tomatoes and IMDb for movies or Goodreads for books -- are annoying. They each have their own ratings scales where the same rating means different things on different sites. Ratings often don't use the full scale. And heaven help you if you happen to come across an item with a max score but only 1 or 2 ratings.

The article [Whose ratings should you trust?] by Alex Olteanu does a good job of capturing my frustration. I want ratings to look like this:

### Picture of normal

But end up with ratings that look like this:

### Picture of actual ratings


In this post, I will "fix" ratings by addressing two things:

- Items with few ratings (Empirical Bayes estimation)
- Not using the entire scale


We will use a dataset of 9,000 children's books that have been rated from 1-5 stars.

Specifically, you will learn to apply a Dirichlet-Multinomial conjugate prior for shrinkage (empirical Bayes estimation)


## Setup

First, we'll load our packages and import the data. In addition to `tidyverse`, we'll use:

- `scales` for nicely-formatted numbers and useful re-scaling functions
- `stats4` and `broom` to help us with our empirical Bayes estimation
- `extrafont` and `fishualize` to make our graphs look nice
- `gganimate` to visualize what exactly empirical Bayes estimation does to the ratings

```{r setup-and-import, warnings = FALSE, message = FALSE}
library(tidyverse)
library(scales)
library(stats4)
library(broom)
library(extrafont)
library(fishualize)
library(gganimate)

theme_set(theme_light())

books <- read_tsv("https://raw.githubusercontent.com/tacookson/data/master/childrens-book-ratings/childrens-books.txt") %>%
  # Select only fields we're using (book identifiers and ratings)
  select(isbn, title, rating:rating_1)
```  
\  

We're not doing any exploratory data analysis or feature engineering, so our data is simple: just the ISBN and title of the book, the raw rating, and the number of people who rated the book at each star level.

```{r data-inspection}
books %>%
  glimpse()
```  
\  


### Distribution

Distribution of ratings:

- Centred on 3.whatever
- Two spikes 

```{r original-rating-distribution, fig.align = 'center', fig.width = 8, fig.asp = 0.7}
books %>%
  filter(!is.na(rating)) %>%
  ggplot(aes(rating)) +
  geom_histogram(binwidth = 0.1)
```

```{r rating-pct-distribution, fig.align = 'center', fig.width = 8, fig.asp = 0.7}
rating_pct <- books %>%
  filter(rating_count > 0) %>%
  mutate_at(vars(rating_5:rating_1), ~ . / rating_count)

# Filter for books with at least 500 reviews
rating_pct %>%
  filter(rating_count > 500) %>%
  pivot_longer(cols = rating_5:rating_1) %>%
  # Create readable label for number of stars given
  mutate(stars_label = paste(parse_number(name), "stars"),
         stars_label = ifelse(stars_label == "1 stars", "1 star", stars_label)) %>%
  ggplot(aes(value)) +
  geom_histogram(binwidth = 0.02) +
  facet_wrap(~ stars_label) +
  scale_x_continuous(labels = label_percent()) +
  labs(title = "Title",
       x = "% of ratings",
       y = "Number of books") +
  theme(text = element_text(family = "Bahnschrift"),
        strip.text = element_text(size = 12, colour = "black"),
        strip.background = element_blank(),
        panel.grid.minor = element_blank())
```

```{r dirichlet-multinomial, message = FALSE}
# Create a matrix to feed our MLE of Dirichlet-Multinomial
rating_matrix <- books %>%
  filter(rating_count > 500) %>%
  select(rating_5:rating_1) %>%
  as.matrix()

# Fit a Dirichlet Multinomial distribution
dm_fit <- DirichletMultinomial::dmn(rating_matrix, 1)

# Write a function to tidy DMN object (which dm_fit is)
tidy.DMN <- function(x, ...) {
  ret <- as.data.frame(x@fit)
  as_tibble(fix_data_frame(ret, c("conf.low", "estimate", "conf.high")))
}

# Tidy the DMN fit
dm_params <- tidy(dm_fit)

# Get parameters into a useful format
par <- dm_params %>%
  separate(term, into = c("constant", "rating_stars"), sep = "_", convert = TRUE) %>%
  select(rating_stars,
         prior_ratings = estimate)

# Calculate total prior ratings and mean (used for graphing)
par_total <- sum(par$prior_ratings)
par_mean <- par %>%
  summarise(prior_rating = sum(rating_stars * prior_ratings) / sum(prior_ratings)) %>%
  pull(prior_rating)
```

```{r calculate-empirical-bayes-rating, message = FALSE}
# Calculate empirical Bayes rating using our prior
books_eb <- books %>%
  pivot_longer(rating_5:rating_1,
               names_to = c("rating_stars"),
               names_pattern = "rating_(.*)",
               names_transform = list(rating_stars = as.integer),
               values_to = "ratings") %>%
  left_join(par, by = "rating_stars") %>%
  group_by(isbn, title, rating_count) %>%
  summarise(rating_calc = sum(rating_stars * ratings) / sum(ratings),
            rating_eb = sum(rating_stars * (ratings + prior_ratings)) / sum(ratings + prior_ratings)) %>%
  ungroup()
```


### Animations

```{r books-shrunk-data}
books_shrunk <- books_eb %>%
  filter(rating_count > 0) %>%
  select(isbn, title, rating_count, rating_calc, rating_eb) %>%
  pivot_longer(rating_calc:rating_eb, names_to = "rating_type", values_to = "rating") %>%
  mutate(rating_type = ifelse(rating_type == "rating_calc", "Original Rating", "Empirical Bayes Rating"))
```

```{r animation-all-ratings, fig.align = 'center', fig.width = 8, fig.asp = 0.7}
# Create base plot
p <- books_shrunk %>%
  ggplot(aes(rating_count, rating, col = rating_count)) +
  geom_point(alpha = 0.2) +
  geom_hline(yintercept = par_mean,
             lty = 2,
             size = 1,
             col = "red") +
  scale_colour_fish(option = "Ostracion_whitleyi", trans = "log") +
  scale_x_log10(labels = label_comma(accuracy = 1),
                breaks = 10 ^ c(0:5)) +
  labs(subtitle = "Dashed line shows Bayesian prior for a book with 0 ratings",
       x = "Number of ratings",
       y = "Rating") +
  theme(legend.position = "none",
        text = element_text(family = "Bahnschrift"),
        axis.text = element_text(size = 12),
        plot.title = element_text(size = 18),
        panel.grid.minor.x = element_blank())

# Set animation parameters
anim <- p +
  transition_states(rating_type,
                    transition_length = 1.5,
                    state_length = 2) +
  ease_aes("cubic-in-out") +
  ggtitle("{closest_state}")

# Create animation
anim
```

```{r animation-200-ratings-or-less, fig.align = 'center', fig.width = 8, fig.asp = 0.7}
# Create base plot
p_filtered <- books_shrunk %>%
  filter(rating_count <= 200) %>%
  ggplot(aes(rating_count, rating, col = rating_count)) +
  geom_point(alpha = 0.4) +
  geom_hline(yintercept = par_mean,
             lty = 2,
             size = 1,
             col = "red") +
  scale_colour_fish(option = "Ostracion_whitleyi") +
  scale_x_continuous(breaks = seq(0, 200, by = 25)) +
  labs(subtitle = paste0("Dashed line shows Bayesian prior for a book with 0 ratings",
                        "\n",
                        "(Only books with 200 ratings or less shown)"),
       x = "Number of ratings",
       y = "Rating") +
  theme(legend.position = "none",
        text = element_text(family = "Bahnschrift"),
        axis.text = element_text(size = 12),
        plot.title = element_text(size = 18),
        panel.grid.minor.x = element_blank())

# Set animation parameters
anim_filtered <- p_filtered +
  transition_states(rating_type,
                    transition_length = 1.5,
                    state_length = 1.5) +
  ease_aes("cubic-in-out") +
  ggtitle("{closest_state}")

# Create animation
anim_filtered
```

```{r shrinkage-amount, fig.align = 'center', fig.width = 8, fig.asp = 0.7}
# Amount that the score was changed based on shrinkage
books_eb %>%
  filter(rating_count > 0) %>%
  select(isbn, title, rating_count, rating_calc, rating_eb) %>%
  filter(rating_count <= 200) %>%
  mutate(rating_change = rating_eb - rating_calc) %>%
  ggplot(aes(rating_count, rating_change, col = rating_count)) +
  geom_point(alpha = 0.2) +
  geom_hline(yintercept = 0, lty = 2, size = 1, col = "grey30") +
  scale_colour_fish(option = "Oncorhynchus_keta") +
  expand_limits(y = c(-1, 2)) +
  scale_x_continuous(breaks = seq(0, 200, by = 25)) +
  scale_y_continuous(breaks = seq(-1, 2, by = 0.5)) +
  labs(title = "Fewer Ratings = More Shrinkage",
       subtitle = "As books get more ratings, our Bayesian prior has less influence",
       x = "Number of ratings",
       y = "Change in rating from shrinkage") +
  theme(legend.position = "none",
        text = element_text(family = "Bahnschrift"),
        axis.text = element_text(size = 12),
        plot.title = element_text(size = 18),
        panel.grid.minor.y = element_blank())
```




## Scaling

```{r scale, fig.align = 'center', fig.width = 8, fig.asp = 0.7}
scaled <- books_eb %>%
  mutate(scaled_rating = rescale(rating_eb, to = c(1, 5)))

scaled_mean <- mean(scaled$scaled_rating)

scaled %>%
  ggplot(aes(scaled_rating)) +
  geom_histogram(binwidth = 0.1) +
  geom_vline(xintercept = scaled_mean, lty = 2, size = 1, col = "red")
```

Explanation of how we could rescale to fit a preferred shape (e.g., mean is always 3 stars, equal proportion of above average and below average books, and equal proportion of excellent and terrible books). But re-scaling with the empirical distribution maintains that there is a slight skew with small tails.



## Additional Stuff

Additional things we could do:

- Apply to different genres
- Extend the model to, e.g., account for books with more ratings probably being higher-rated
- Re-scale according to an assumption on what the distribution should look like instead of the empirical distribution